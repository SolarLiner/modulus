<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../index.css">
  <title>Modulus</title>
</head>

<body>
  <h1>Modulus (Article)</h1>
  <hr>
  <p><i>Building an SMT solver from the ground up</i></p>
  <a href="../index.html">acceuil</a>
  <a href="./blog.html">blog</a>
  <ul>
    <li>Auteur : Arthur Correnson</li>
    <li>Email : <a href="mailto:arthur@correnson.@ens-rennes.fr">arthur@correnson.@ens-rennes.fr</a></li>
    <li>Date : 30/06/21 </li>
  </ul>
  <h2>A tout petit solveur SAT en OCaml</h2>
  <p>
    Dans un <a href="./post1.html">premier article</a> nous avons vu qu'un solveur SAT était une composante principale
    dans
    un solveur SMT. L'object de cette article est de présenter un tout petit solveur SAT. Ce solveur sera écrit en OCaml
    comme le reste du <a href="../index.html">projet Modulus</a>.
  </p>
  <h3>Rappels et définitions</h3>
  <h4>Syntaxe</h4>
  <p>
    Un solveur SAT permet de résoudre le problème de la satisfiabilité d'une formule booléenne.
    Formellement une formule booléenne <span class="math">&phi;</span> construite sur l'ensemble de variables <span
      class="math">V</span> est
    soit :
  <ul>
    <li>Une variable <span class="math">x &isin; V</span></li>
    <li>Une conjonction (et) <span class="math">&phi; &and; &psi;</span> (avec <span class="math">&phi;
        &psi;</span> des formules)</li>
    <li>Une disjonction (ou) <span class="math">&phi; &or; &psi;</span> (avec <span class="math">&phi;
        &psi;</span> des formules)</li>
    <li>Une négation (non) <span class="math">&not;&phi;</span> (avec <span class="math">&phi;</span> une formule)
    </li>
  </ul>
  </p>
  <p>
    pour représenter les formules booléenne en OCaml, on définit un type <span class="math">formula</span> :
    <code><pre>
      type formula =
        | Var of V
        | Or of formula * formula
        | And of formula * formula
        | Neg of formula
    </pre></code>
  </p>
  <h4>Sémantique</h4>
  <p>
    Maintenant que nous avons défini la syntaxe des formules booléennes, il faut leur donner un sens (une "sémantique"
    pour faire plaisir aux logiciens). Étant donnée une fonction <span class="math">&lambda; : V &rightarrow; {vrai;
      faux}</span> qui
    représente l'affectation d'une valeur de vérité aux variables, la sémantique d'une formule <span
      class="math">&phi;</span> pour
    cette affectation est notée <span class="math">[[&phi; | &lambda;]]</span> :
  <ul>
    <li><span class="math">[[x | &lambda;]] = &lambda;(x)</span></li>
    <li><span class="math">[[&phi; &and; &psi; | &lambda;]] = [[x | &lambda;]] et [[x | &lambda;]]</span></li>
    <li><span class="math">[[&phi; &or; &psi; | &lambda;]] = [[x | &lambda;]] ou [[x | &lambda;]]</span></li>
    <li><span class="math">[[&not;&phi; | &lambda;]] = non [[x | &lambda;]]</span></li>
  </ul>
  Les opérateurs <span class="math">et, ou, non</span> sont simplement à prendre au sens des opérateurs usuels
  associés au type
  <span class="math">bool</span> dans les langages de programmation. Le problème SAT peut ensuite être vu
  comme celui de trouver,
  étant donné une formule <span class="math">&phi;</span>, une
  affectation <span class="math">&lambda;</span> telle que <span class="math">[[&phi; | &lambda;]] =
    vrai</span>
  </p>
  <p>
    Une implémentation OCaml naïve de la sémantique peut-être faite en représentant les affectations par des fonctions
    de type <span class="math">V &rightarrow; bool</span>
  </p>
  <code><pre>
    let eval (f : formula) (e : V -> bool) =
      match f with
      | Var x -> e x
      | Or (f1, f2) -> (eval f1 e) || (eval f1 e)
      | And (f1, f2) -> (eval f1 e) && (eval f1 e)
      | Neg f1 -> not (eval f1 e)
  </pre></code>
  <p>
    En pratique, cette définition n'est pas très optimale car elle nécessite de représenter les affectations comme des
    fonctions. Construire des fonctions à la volé est facile en OCaml, mais ce peut-être assez coûteux en mémoire.
    Par ailleurs, écrire des algorithmes complexes pour transformer des fonctions peut s'avérer assez pénible. Pour
    résoudre ces problèmes, on représentera plutôt les affectations comme une liste des variables auxquelles on souhaite
    affecter la valeur <span class="math">vrai</span>. Les variables non présentes dans la liste seront considérées
    comme associées à
    la valeur <span class="math">faux</span>.
  </p>
  <h3>Forme normale conjonctive</h3>
  <p>
    La structure "en arbre" des formules comme définis ci-dessus rend la programmation des raisonnements difficiles.
    Pour écrire un solveur, une représentation plus "linéaire" des formules est plus pratique. Pour cela on introduit la
    notion de <em>forme normale conjonctive</em> (CNF).
  <ul>
    <li><b>un littéral</b> est une variable (<span class="math">x</span>) ou sa négation (<span
        class="math">&not;x</span>)</li>
    <li><b>une clause</b> est une disjonction de littéraux (<span class="math">l1 &or; l2 &or; ... &or; lN</span>)</li>
    <li><b>une formule en CNF</b> est une conjonction de clauses (<span class="math">c1 &and; c2 &and; ... &and;
        cN</span>)</li>
  </ul>
  Par exemple la formule <span class="math">(x &or; &not;y) &and; z</span> est en CNF.
  </p>
  <p>
    Un résultat fondamental est que toute formule booléenne peut-être transformée en une formule équivalente qui est
    en
    forme CNF. A partir de maintenant on considérera donc que toutes les formules sont en forme CNF ce qui simplifiera
    beaucoup les raisonnements.
  </p>
  <p>
    Dans une formule en forme CNF, la structure imposée est telle qu'il n'est plus nécessaire de faire apparaître
    explicitement les connecteurs logiques. En considérant les variables comme des entiers (ce qui
    revient à numéroter les variables <span class="math">x1, x2, ... xN</span>) on peut représenter facilement les
    formules en forme
    CNF :
  <ul>
    <li>les littéraux sont des entiers <span class="math">n</span> ou <span class="math">-n</span> selon leur
      signe</li>
    <li>les clauses sont des ensembles de littéraux</li>
    <li>les formules en cnf sont des ensembles de clauses</li>
  </ul>
  </p>
  <p>
    Traduit en OCaml, on peut donc définir les formules en CNF de façon très simple :
  </p>
  <code><pre>
    type literal = int
    type clause = literal list
    type cnf = clause list
  </pre></code>
  <p>
    On programme ensuite une fonction de conversion en forme CNF (dont on ne détaillera pas l'implémentation ici).
  </p>
  <code><pre>
    let cnf (f : formula) : cnf = ...
  </pre></code>
  <p>
    Enfin, les affectations peuvent être représentées comme un ensemble de littéraux. Si un littéral apparaît dans
    l'ensemble, on associe sa variable à <span class="math">vrai</span> ou <span class="math">faux</span> en fonction
    de son signe. Par exemple,
    l'affectation <span class="math">{-1, 2, 3}</span> peut-être interprétée comme <span class="math">x1 := faux,
      x2 := vrai, x3 := vrai</span>.
    Les variables n'apparaissant pas dans la liste sont ignorées. Un problème SAT peut également ne pas avoir
    de
    solution, on définit donc un type <span class="math">solution</span> qui prend en compte cette
    possibilité.
  </p>
  <code><pre>
    type affectation = literal list
    type solution =
      | SAT of affectation
      | UNSAT
  </pre></code>
  <h3>Le solveur</h3>
  <p>
    On s'attaque maintenant à l'écriture d'un petit solveur. On suppose que les formules sont déjà mises en forme CNF
    donc le solveur prend la forme d'une fonction de type <span class="math">sat : cnf &rightarrow; solution</span>
  </p>
  <p>
    L'idée générale d'un solveur SAT est d'alterner deux phases :
  <ul>
    <li>Une phase de <b>décision</b> où l'on choisit une variable pour lui attribuer une valeur de vérité (ceci est
      équivalent à juste choisir un littéral et choisir de le rendre <span class="math">vrai</span>)</li>
    <li>Une phase de <b>propagation</b> où l'on simplifie la formule grâce à la dernière décision</li>
  </ul>
  Par exemple dans la formule <span class="math">(&not;x1 &or; x2) &and; (x3)</span>, si on décide <span class="math">x1
    := faux</span>, alors la
  clause <span class="math">(&not;x1 &or; x2)</span> devient vraie et la formule se simplifie en juste <span
    class="math">x3</span>.
  De même, si l'on fait la décision <span class="math">x3 := faux</span> dans la formule <span class="math">(x3)</span>,
  alors la clause
  <span class="math">(x3)</span> devient vide ce qui marque une contradiction : il faut faire une autre
  décision pour
  <span class="math">x3</span>.
  </p>
  <p>
    D'une manière générale les règles de propagation d'une décision (représentée par un litéral) <span
      class="math">l</span> sont les
    suivantes :
  <ol>
    <li>si une clause contient le littéral <span class="math">l</span>, on supprime cette clause
      car elle est rendue vraie</li>
    <li>si une clause contient la négation de <span class="math">l</span>, on supprime le littéral
      de cette clause</li>
  </ol>
  </p>
  <p>
    On programme une fonction <span class="math">propagate : literal &rightarrow; cnf &rightarrow;
      cnf</span> qui étant donnés un
    litéral représentant une décision et une formule en CNF, simplifie cette formule en suivant ces
    règles.
  </p>
  <code><pre>
    let propagate l f =
      match f with
      | [] -> []
      | c::cs ->
        if List.mem x c then c::(propagate l cs)
        else (List.filter ((=) (-c))
  </pre></code>
  <p>
    Trois issues sont possibles après un cycle de décision/propagation.
  <ol>
    <li>la formule contient une clause vide: cela signifie qu'il y a une contradiction et qu'il faut
      faire la décision
      inverse de celle qui a vient d'être propagée ne façon non fructueuse</li>
    <li>la formule ne contient plus aucune clause: cela signifie que la résolution est finie et que
      l'ensemble des
      décision faites constitue une solution</li>
    <li>la formule ne contient pas la clause vide mais contient toujours des clauses: dans ce cas on
      relance un cycle de
      décision/propagation sur une nouvelle variable</li>
  </ol>
  On peut donc maintenant dériver un algorithme simple pour la résolution.
  </p>
  <code><pre>
    let rec sat (f : cnf) =
      match f with
      | [] -> SAT [] (* la solution du problème vide est l'affectation qui ignore toute variable *)
      | c::cs ->
        match c with
        | [] -> UNSAT (* on a trouvé une clause vide *)
        | l::ls ->
          (* on fait une décision sur le litéral l *)
          match sat (propagate l f) with
          | Some s -> Some (l::s) (* on a trouvé une solution *)
          | None ->
            (* l := vrai ne marche pas, on essaye l := faux *)
            sat (propagate (-l) f)
  </pre></code>
  <h3>Disclaimer</h3>
  <p>
    Cet algorithme a l'avantage d'être très facile à implémenter et très facile à comprendre. On peut
    même facilement
    faire sa <a href="https://github.com/jdrprod/SATurne">preuve de correction en Coq</a> ! En
    revanche, c'est un
    algorithme assez inefficace en pratique. Toutefois, il reste beaucoup plus efficace qu'un
    algorithme naïf qui
    consiste
    à tester toutes les possibilités. Nous verrons dans un futur article comment améliorer
    significativement ce même
    algorithme puis comment implémenter un "vrai" solveur SAT qui résistera au passage à l'échelle.
  </p>
</body>