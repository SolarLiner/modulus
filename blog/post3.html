<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../index.css">
  <title>Modulus</title>
</head>

<body>
  <h1>Modulus (Article)</h1>
  <hr>
  <p><i>Building an SMT solver from the ground up</i></p>
  <a href="../index.html">acceuil</a>
  <a href="./blog.html">blog</a>
  <ul>
    <li>Auteurs : Arthur Correnson & Amine Naim </li>
    <li>Email :
      <a href="mailto:arthur.correnson@ens-rennes.fr">arthur.correnson@ens-rennes.fr</a>
    </li>
    <li>Date : 28/07/2021 </li>
  </ul>
  <h2>Gestion des entrées au format SMT-LIB</h2>
  <p>
    Pour pouvoir communiquer avec un solveur SMT, il faut s'entendre sur le format dans lequel présenter les problèmes à
    résoudre. Le standard <a href="http://smtlib.cs.uiowa.edu/">SMT-LIB</a>
    définit un langage commun pour intérroger tous les solveurs SMT. Cela permet d'utiliser n'importe quel solveur via
    une même
    interface unifiée sans avoir à ce soucier des détails d'implémentation. Plutôt que de définir notre propre langage
    d'entrée pour le solveur Modulus, nous avons fait le choix d'accepter des entrées au format SMT-LIB. Cela nous
    évite d'une part d'avoir à réfléchir sur notre propre langage et d'autre part cela rend Modulus compatible avec tous
    les solveurs ainsi que les différents outils développés par la communauté SMT. En particulier, il existe des grandes
    banques
    de problèmes aux format SMT pouvant être utilisés pour tester les solveurs. En rendant Modulus compatible avec le
    standard, nous pourrons bénéficier de ces tests.
    Dans ce blog, nous présentons succinctement une première approche pour la lecture de
    ce format d'entrées.
  </p>
  <h3>Le format SMT-LIB</h3>
  <p>
    Le langage SMT-LIB est un véritable petit langage de script qui permet de piloter les solveurs. Il permet de régler
    les
    différents paramètre du solveur, de demander la résolution de certaines formules et de programmer l'affichage des
    résultats. Afin de pouvoir rapidement tester notre solveur, nous commençons par implémenter un tout petit fragment
    de ce langage qui nous permet de déclarer des variables entières et de demander la résolution d'équations simples.
  </p>
  <pre><code>
    (set-logic QF_LIA)
    (declare-const x Int)
    (assert (and (= x 1) (= x 2))
    (check-sat)
    (exit)
  </code></pre>
  Le fichier SMT-LIB ci dessus règle le solveur pour l'utilisation de la théorie de l'arithmétique linéaire entière et
  sans quantificateurs, déclare une variable <span class="math">x</span> de type <span class="math">Int</span> et
  demande si la formule
  <span class="math">x = 1 &wedge; x = 2</span> est satisfiable. Ici la formule
  n'est pas satisfiable, mais dans le cas contraire on peut obtenir un modèle
  en utilisant la commande <span class="math">(get-model)</span>. Il existe beaucoup d'autres commandes mais dans
  un premier temps
  les commandes <span class="math">(set-logic ...)</span>, <span class="math">(declare-const ...)</span>, <span
    class="math">(assert ...)</span>,
  <span class="math">(check-sat)</span>, <span class="math">(get-model)</span> et <span class="math">(exit)</span> nous
  suffiront pour la plupart des usages.
  <h3>Définition des commandes usuelles</h3>
  <ul>
    <li><span class="math">(set-logic &lt;logic&gt;)</span>:
      Cette commande est la première commande qui doit apparaître dans un fichier SMT-LIB. Elle
      configure les théories
      que le solveur est autorisé à utiliser au cours de la résolution. Les différentes
      combinaisons de théories sont
      appelés des <i>logics</i> dans le standard SMT-LIB. Par exemple, <b>QF_LIA</b> désigne la
      théorie de
      l'arithmétique linéaire sans quantificateurs sur les nombres entiers (<i>Quantifier Free
        Linear Integer
        Arithmetic</i>). Si l'on souhaite activer toutes les théories supportées par le solveur,
      on peut passer le mot
      clef <b>ALL</b> en paramètre.
    </li>
    <li><span class="math">(assert &lt;formula&gt;)</span>: La commande <b>assert</b> permet
      d'ajouter une formule à résoudre dans le
      contexte actuelle. Les formules sont écrites sous forme de <a
        href="https://fr.wikipedia.org/wiki/S-expression">S-expressions</a>. Par exemple la
      formule <span class="math">(p &wedge; q)
        &vee; &not; r</span> s'écrit <span class="math">(or (and p q) (not r))</span>
    </li>
    <li><span class="math">(declare-const &lt;x&gt; &lt;t&gt;)</span>: La commande
      <b>declare-const</b> permet de déclarer une
      nouvelle variable et son type. Dans un premier temps, nous supporterons uniquement les
      variables de type
      <span class="math">Int</span>. Les variables non déclarées provoquent une erreur à
      l'exécution du solveur.
    </li>
    <li><span class="math">(check-sat)</span>: cette commande demande au solveur de vérifier la
      satisfiabilité de l'ensemble des
      formules précédemment enregistrées via la commande <span class="math">(assert ...)</span>.
      Notons que l'on peut très bien
      demander plusieurs fois de vérifier la satisfiabilité tout en ayant rajouté des nouvelles
      formules entre temps :
      <pre><code>
        (assert (x = 1))
        (check-sat)
        ; SAT
        (assert (x = 2))
        (check-sat)
        ; UNSAT
      </code></pre>
    </li>
    <li><span class="math">(exit)</span>: cette commande marque la fin de l'execution d'un script
    </li>
  </ul>
  <h3>S-expressions en OCaml</h3>
  <p>
    Le langage SMT-LIB est basé sur l'usage des S-expressions. Il s'agit d'une notation très simple
    pour décrire des
    programmes ou des données dans un format textuel. Formellement, une S-expression est soit un
    symbole (par exemple,
    un nom de variable <span class="math">x</span> ou la constante <span class="math">1</span>) soit
    une liste de S-expressions délimitée par des
    parenthèses :
  </p>
  <pre><code>
    &lt;s-expr&gt; ::= &lt;symbol&gt; | ( &lt;s-expr&gt;* )
  </code></pre>
  <p>
    Pour le moment, les seuls symboles qui nous intéressent sont les identifiants comme les noms de
    variable et les
    noms de commande ainsi que les constantes entières. Les S-expressions s'encode alors en OCaml
    par le type suivant :
  </p>
  <pre><code>
    type sexp =
      | Sym of string
      | Int of int
      | Cons of sexp list
  </code></pre>
  <p>
    Chaque commande SMT-LIB est représentée par une S-expression et un script est une liste de
    plusieurs commandes.
    Ainsi, le fichier SMT-LIB présenté plus tôt peut-être modélisé en OCaml de la façon suivante :
  </p>
  <pre><code>
    [
      Cons [Sym "set-logic"; Sym "QF_LIA"];
      Cons [Sym "declare-const"; Sym "x"; Sym "Int"];
      Cons [Sym "assert"; Cons [Sym "and";
        [Sym "="; Sym "x"; Int 1];
        [Sym "="; Sym "x"; Int 2];
      ];
      Cons [Sym "check-sat"];
      Cons [Sym "exit"];
    ]
  </code></pre>
  <p>
    Nous souhaitons à présent écrire un parser qui extrait ce type de représentation à partir d'un
    fichier texte au
    format SMT-LIB. Pour se faire, nous utiliserons une technique simple de <i>parsing</i> par <a
      href="https://en.wikipedia.org/wiki/Parser_combinator">combinateurs</a>.
  </p>
  <h3>Parseurs Combinateurs</h3>
  <p>
    Un parseur est une fonction de type <span class="math">string &rightarrow; t</span> où <span class="math">t</span>
    est un type
    quelconque qui
    représente une information à extraire d'un texte. Dans notre cas, nous souhaitons extraire
    une représentation
    structurée des S-expressions à partir d'un texte, notre parser sera donc une fonction de la
    forme <span class="math">parse_sexpr
      : string &rightarrow; sexp</span>. Il existe plusieurs techniques qui permettent de
    programmer une telle fonction.
    Ici, nous allons utiliser un <b>parseur combinateur</b>. Il s'agit d'une technique de
    <i>parsing</i> qui se met très
    facilement en oeuvre dans un langage de programmation fonctionnelle et qui repose sur
    l'idée de combiner plusieurs
    petits parseurs (donc plusieurs petites fonctions de type <span class="math">string
      &rightarrow; t</span>) en utilisant des
    opérateurs
    appellés combinateurs. Par exemple, étant donné deux fonctions <span class="math">parserA : string &rightarrow;
      string</span> et
    <span class="math">parserB
      : string &rightarrow; string</span> qui détectent respectivement les mots clefs
    <span class="math">"A"</span> et
    <span class="math">"B"</span>,
    on
    peut obtenir les parseurs suivants :
  <ul>
    <li><span class="math">parserA | parserB</span> qui reconnaît soit <span class="math">"A"</span> soit <span
        class="math">"B"</span></li>
    <li><span class="math">(parserA)*</span> qui reconnaît zero ou plusieurs fois
      <span class="math">"A"</span>
    </li>
    <li><span class="math">(parserA)+</span> qui reconnaît une ou plusieurs fois
      <span class="math">"B"</span>
    </li>
  </ul>
  On peut également faire des manipulations plus sophistiquées comme par exemple
  combiner des parseurs avec des
  applications de fonctions. Par exemple, si on se donne une fonction <span class="math">to_lower : string &rightarrow;
    string</span> qui converti
  une chaîne de caractères capitales en caractères minuscules, on peut
  construire un parseur <span class="math">
    (parserA &Rightarrow;
    to_lower)</span> qui reconnaît le mot clef <span class="math">"a"</span>.
  </p>
  <p>
    Cette technique est par essence très modulaire et permet aisément de fabriquer des parseurs de
    complexité croissante
    à moindre coût. La seule difficulté est d'implémenter un catalogue initial de parseurs utiles
    (par exemple
    des parseurs qui reconnaissent les constantes entières, les mots alphanumériques, les symboles
    de ponctuations etc)
    et de combinateurs pour les composer entre eux. Une fois ces élements fournis, il est très
    facile de construire des
    parseurs plus sophistiqués en combinant les parseurs existants. Nous avons développé un module
    minimaliste appellé
    <a href="https://github.com/jdrprod/modulus/blob/main/src/utils/parsing.ml">Parsing</a> qui
    propose quelques
    combinateurs utiles. Nous reviendrons certainement sur l'implémentation détaillée de ce module
    dans un futur poste.
  </p>
  <h3>Conversions et typage</h3>
  <p>
    Une fois que nous avons le moyen de lire une entrée au format SMT-LIB et de la convertir en une
    valeur OCaml de type
    <span class="math">sexp</span>, il reste quelques problèmes à adresser. Tout d'abord, la logique
    de SMT-LIB est une logique du
    premier ordre <b>typée</b>. La formule <span class="math">(forall ((x Int) (y Real)) (= x
      y))</span> par exemple est incorrecte
    car
    les types <span class="math">Int</span> et <span class="math">Real</span> ne sont pas
    compatibles. Il nous faut donc développer un
    vérificateur de types qui assure que les formules décrites dans un fichier SMT soient
    correctement typées. D'une
    manière générale, manipuler une valeur de type <span class="math">sexp</span> n'est pas
    très confortable, c'est un format
    très générique qui ne représente pas forcément du code SMT-LIB valide. Avant de se
    soucier de la vérification des
    types, on commence donc par convertir les S-expressions en une structure plus simple
    qui encode <b>uniquement</b>
    les constructions syntaxique autorisées par le standard SMT.
  </p>
  <p>
    On distingue plusieurs parties dans un fichier SMT-LIB. D'une part les commandes et d'autre part
    les formules. Nous
    modélisons les deux par des types OCaml.
  </p>
  <p>
    Comme dit plus tôt, nous commençons par considérer uniquement des problèmes d'arithmétique
    entière faisant
    intervenir l'égalité, l'addition des variables entières et des constantes. Un terme à donc la
    forme suivante :
  </p>
  <pre><code>
    type term =
      | Var of string
      | Cst of int
  </code></pre>
  <p>
    Les formules atomiques sont les assertions de taille minimales que l'on peut faire sur des
    termes de type entier.
    Dans notre cas, les formules atomiques sont uniquement des égalités mais nous étendrons ces
    possibilités plus tard.
  </p>
  <pre><code>
    type atom =
      | Eq of term * term
  <code></pre>
  <p>
    Enfin, nous pouvons construire des formules plus complexes en combinant des formules atomiques
    avec des opérateurs
    logiques.
  </p>
  <pre><code>
    type formula =
      | And of formula * formula
      | Or of formula * formula
      | Neg of formula
      | Atom of atom

    type command =
      | Assert of formula
  </code></pre>
  <p>
    Le type <span class="math">formula</span> représente les formules logiques que notre solveur
    pourra manipuler. Il reste à
    représenter les commandes du standard SMT-LIB. Nous déclarons un type <span class="math">command</span> qui permet
    de représenter
    une commande ainsi que le type <span class="math">smt_logic</span> pour représenter les noms
    des différentes logiques du standard
    SMT-LIB et un type <span class="math">smt_type</span> pour représenter les différents
    types. Seul les types <span class="math">Int</span>
    (pour les constantes et variables entières) et <span class="math">Bool</span> (pour
    les formules) sont nécessaire pour le
    moment. De même, nous ne déclarons que les logiques <span class="math">ALL</span> et
    <span class="math">QF_LIA</span>.
  </p>
  <pre><code>
    type smt_type = Int | Bool

    type smt_logic = ALL | QF_LIA

    type command =
      | Assert of formula
      | DeclareConst of string * smt_type
      | SetLogic of smt_logic
      | CheckSat
      | GetModel
      | Exit

    type smt_script = command list
  </code></pre>
  <p>
    Avec ces nouveaux types, notre fichier SMT-LIB d'exemple s'encode de la façon suivante :
  </p>
  <pre><code>
    [
      SetLogic QF_LIA;
      DeclareConst (Var "x", Int);
      Assert (And (
        Atom (Eq (Var "x", Cst 1)),
        Atom (Eq (Var "x", Cst 2)),
      ));
      CheckSat;
      Exit;
    ]
  </code></pre>
  <p>
    Cet encodage est beaucoup plus précis que l'encodage sous forme de S-expression et permet de
    raisonner sur les
    entrées sans faire d'hypothèses sur la forme des S-expressions.
  </p>
  <p>
    Pour vérifier le bon typage d'un fichier SMT-LIB, nous implémentons une fonction <span
      class="math">type_check_script : script
      &rightarrow; unit</span> qui lève une exception si le script passé en paramètre est mal typé.
    On distingue
    plusieurs erreurs de typage : les incompatibilités de types (par exemple une addition entre un
    entier et un réel),
    les imprécisions (une variable non déclarée par exemple) et les ambiguïtés (une variable
    déclarée plusieurs fois
    avec des types différents par exemple). Notons qu'au regard de la logique très minimaliste que
    nous considérons,
    seules les imprécisions et les ambiguïtés peuvent se produire car toutes les formules
    atomiques sont nécessairement
    bien typée.
  </p>
  <pre><code>
    (* Duplication de variables *)
    exception VarDup of string
    (* Type non renseigné *)
    exception NoType of string
  </code></pre>
  <p>
    Pour écrire un vérificateur de type, nous avons besoin de conserver en mémoire les types des
    variables déjà connues
    ou déclarées. Pour se faire, on utilise une table de <i>hash</i> qui à chaque nom de variable
    associe un type. Cette
    table est appellée <b>environnement de typage</b>.
    Lorsque l'on vérifie le bon typage d'une commande,
    si la commande est de la forme <span class="math">DeclareConst (x, tx)</span> on met à jour
    l'environnement de typage en
    associant le type <span class="math">tx</span> à la variable <span class="math">x</span>. Si
    la variable est déjà déclarée on lève une
    exception. Pour évaluer un script, on commence par créer un nouvel environnement de typage
    vide puis on vérifie
    dans l'ordre le typage de toutes les commandes du script.
  </p>
  <pre><code>
    type typing_env = (string, smt_type) Hashtbl.t

    let rec type_check_term (t : term) (e : typing_env) =
      match t with
      | Var x -> begin
        match Hashtbl.find_opt e x with
        | Some Int -> ()
        | _ -> raise (NoType x)
        end
      | Cst _ -> ()
      | Add (a, b) -> type_check_term a e; type_check_term b e

    let rec type_check_formula (f : formula) (e : typing_env) =
      match f with
      | And (f1, f2) -> type_check_formula f1 e; type_check_formula f2 e
      | Or (f1, f2) -> type_check_formula f1 e; type_check_formula f2 e
      | Neg f' -> type_check_formula f' e
      | Atom (Eq (a, b)) -> type_check_term a e; type_check_term b e

    let type_check_command (c : command) (e : typing_env) =
      match c with
      | Assert f -> type_check_formula f e
      | DeclareConst (x, t) -> begin
        match Hashtbl.find_opt e x with
        | Some _ -> raise (VarDup x)
        | None -> Hashtbl.add e x t
        end
      | _ -> ()

    let type_check s =
      let e : typing_env = Hashtbl.create 10 in
      List.iter (fun c -> type_check_command c e) s
  </code></pre>
  <h3>Et ensuite ?</h3>
  <p>
    Les ajouts que nous avons faits permettent un support très minimaliste pour la lecture du format
    SMT-LIB. En
    décomposant la lecture des entrées en deux étapes (une étape de lecture de S-expressions, puis
    une étape de
    conversion des S-expression en commandes), nous rendons possible l'ajout progressif de nouvelles
    <i>features</i> du
    standard SMT-LIB sans pour autant avoir à réécrire notre parseur à chaque fois. Seules les
    conversions <span class="math">sexp
      &rightarrow;
      command</span> doivent être faites ce qui est généralement très simple.
  </p>
  <p>
    Même si, pour l'instant, nous ne supportons qu'un sous ensemble très restreint du standard
    SMT-LIB, le fragment que
    nous avons décrit aujourd'hui nous permettra déjà de mettre en pratique quelques algorithmes de
    résolution pour
    décider des problèmes d'arithmétiques simples.
  </p>

</body>